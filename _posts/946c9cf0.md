---
title: "ベジェ曲線"
weight: 10
num: 28
hash: "946c9cf0"
tags: ["curve"]
---

## 解説/アルゴリズム

まずは 3 点の位置から曲線を描く二次ベジェ曲線の解説をします。

<svg viewBox="0 0 600 200" xmlns="http://www.w3.org/2000/svg" version="1.1">
  <path d="M10 150 L250 30" stroke="#aaa" stroke-width="2"></path>
  <path d="M250 30 L580 180" stroke="#aaa" stroke-width="2" id="p1"></path>
  <g transform="translate(10, 150)">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2"></circle>
    <text fill="#fff" x="-5" y="-10">A</text>
  </g>
  <g transform="translate(250, 30)">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2">
    </circle>
    <text fill="#fff" x="-5" y="-10">B</text>
  </g>
  <g transform="translate(580, 180)">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2">
    </circle>
    <text fill="#fff" x="-5" y="-10">C</text>
  </g>
</svg>
3つの点ABCを用意して、点AB、点BCを直線で結んで2つの線を作ります。

<svg viewBox="0 0 600 200" xmlns="http://www.w3.org/2000/svg" version="1.1">
  <path d="M10 150 L250 30" stroke="#aaa" stroke-width="2"></path>
  <path d="M250 30 L580 180" stroke="#aaa" stroke-width="2" id="p1"></path>
  <g transform="translate(10, 150)">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2"></circle>
    <text fill="#fff" x="-5" y="-10">A</text>
  </g>
  <g transform="translate(250, 30)">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2">
    </circle>
    <text fill="#fff" x="-5" y="-10">B</text>
  </g>
  <g transform="translate(580, 180)">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2">
    </circle>
    <text fill="#fff" x="-5" y="-10">C</text>
  </g>
  <g transform="translate(82, 114)">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2"></circle>
    <text fill="#cd3830" x="-5" y="-10">D<text>
  </g>
  <g transform="translate(349, 75)">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2"></circle>
    <text fill="#cd3830" x="-5" y="-10">E<text>
  </g>
</svg>

ここで線 AB の[線形補間](/9f9e772b/)、線 BC の[線形補間](/9f9e772b/)を求めます。  
補間係数の値は何でもいいのですが、とりあえず 0.3 を設定するとします。

つまり、A ～ B までの距離を 30%進んだ場所と、B ～ C までの距離を 30%進んだ場所の位置を求めます。  
（上記の D、E 地点）

<svg viewBox="0 0 600 200" xmlns="http://www.w3.org/2000/svg" version="1.1">
  <path d="M10 150 L250 30" stroke="#aaa" stroke-width="2"></path>
  <path d="M250 30 L580 180" stroke="#aaa" stroke-width="2"></path>
  <path d="M82 114 L349 75" stroke="#aaa" stroke-width="2"></path>
  <g transform="translate(10, 150)">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2"></circle>
    <text fill="#fff" x="-5" y="-10">A</text>
  </g>
  <g transform="translate(250, 30)">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2">
    </circle>
    <text fill="#fff" x="-5" y="-10">B</text>
  </g>
  <g transform="translate(580, 180)">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2">
    </circle>
    <text fill="#fff" x="-5" y="-10">C</text>
  </g>
  <g transform="translate(82, 114)">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2"></circle>
    <text fill="#cd3830" x="-5" y="-10">D<text>
  </g>
  <g transform="translate(349, 75)">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2"></circle>
    <text fill="#cd3830" x="-5" y="-10">E<text>
  </g>
</svg>
線形補間で求めた位置同士を線で結びます。

<svg viewBox="0 0 600 200" xmlns="http://www.w3.org/2000/svg" version="1.1">
  <path d="M10 150 L250 30" stroke="#aaa" stroke-width="2"></path>
  <path d="M250 30 L580 180" stroke="#aaa" stroke-width="2"></path>
  <path d="M82 114 L349 75" stroke="#aaa" stroke-width="2"></path>
  <g transform="translate(10, 150)">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2"></circle>
    <text fill="#fff" x="-5" y="-10">A</text>
  </g>
  <g transform="translate(250, 30)">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2">
    </circle>
    <text fill="#fff" x="-5" y="-10">B</text>
  </g>
  <g transform="translate(580, 180)">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2">
    </circle>
    <text fill="#fff" x="-5" y="-10">C</text>
  </g>
  <g transform="translate(82, 114)">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2"></circle>
    <text fill="#fff" x="-5" y="-10">D<text>
  </g>
  <g transform="translate(349, 75)">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2"></circle>
    <text fill="#fff" x="-5" y="-10">E<text>
  </g>
  <g transform="translate(162, 102)">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2"></circle>
    <text fill="#cd3830" x="-5" y="-10">F<text>
  </g>
</svg>
その結んだ線から更に線形補間を求めます。補間係数の値は上と同じで0.3です。  
つまり、D～Eまでの距離を30%進んだ場所を求めます。  
（上記のF地点）

この求めた F 地点の位置が二次ベジェ曲線で描かれる曲線の位置になります。

<svg class="svg0" viewBox="0 0 600 200" xmlns="http://www.w3.org/2000/svg" version="1.1">
  <path d="M10 150 L250 30" stroke="#aaa" stroke-width="2"></path>
  <path d="M250 30 L580 180" stroke="#aaa" stroke-width="2"></path>
  <path class="p0" stroke="#aaa" stroke-width="2"></path>
  <path class="bezier" fill="transparent" stroke="#1c8b94" stroke-width="4"></path>
  <g transform="translate(10, 150)">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2"></circle>
    <text fill="#fff" x="-5" y="-10">A</text>
  </g>
  <g transform="translate(250, 30)">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2">
    </circle>
    <text fill="#fff" x="-5" y="-10">B</text>
  </g>
  <g transform="translate(580, 180)">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2">
    </circle>
    <text fill="#fff" x="-5" y="-10">C</text>
  </g>
  <g transform="translate(82, 114)" class="g0">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2"></circle>
    <text fill="#fff" x="-5" y="-10">D<text>
  </g>
  <g transform="translate(349, 75)" class="g1">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2"></circle>
    <text fill="#fff" x="-5" y="-10">E<text>
  </g>
  <g transform="translate(162, 102)" class="g2">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="#1c8b94" stroke-width="2"></circle>
    <text fill="#fff" x="-5" y="-10">F<text>
  </g>
</svg>
補間係数を0.0～1.0まで求めて繋げて軌跡にすると、二次ベジェ曲線を描くことができます。

```text
三つの点から二本の直線を描き、二つの線形補間の点を求める。
二つの点から一本の直線を描き、一つの線形補間の点を求める。
```

まとめると二次ベジェ曲線のアルゴリズムは上記の通りとなります。

```text
N個の点からN-1本の直線を描き、N-1個の線形補間の点を求める
(点が一つになるまでループ)
```

これを上記のように一般化すると、点の数をいくらでも増やし複雑なベジェ曲線を描くことができます。

<svg class="svg1" viewBox="0 0 600 200" xmlns="http://www.w3.org/2000/svg" version="1.1">
  <path d="M10 150 L150 30" stroke="#aaa" stroke-width="2"></path>
  <path d="M150 30 L350 180" stroke="#aaa" stroke-width="2"></path>
  <path d="M350 180 L580 80" stroke="#aaa" stroke-width="2"></path>
  <path class="p0" stroke="#aaa" stroke-width="2"></path>
  <path class="p1" stroke="#aaa" stroke-width="2"></path>
  <path class="p2" stroke="#aaa" stroke-width="2"></path>
  <path class="bezier" fill="transparent" stroke="#1c8b94" stroke-width="4"></path>
  <g transform="translate(10, 150)">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2"></circle>
  </g>
  <g transform="translate(150, 30)">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2">
    </circle>
  </g>
  <g transform="translate(350, 180)">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2">
    </circle>
  </g>
  <g transform="translate(580, 80)">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2">
    </circle>
  </g>
  <g class="g0">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2"></circle>
  </g>
  <g class="g1">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2"></circle>
  </g>
  <g class="g2">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2"></circle>
  </g>
  <g class="g3">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2"></circle>
  </g>
  <g class="g4">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="black" stroke-width="2"></circle>
  </g>
  <g class="g5">
    <circle cx="0" cy="0" fill="#fff" r="4" stroke="#1c8b94" stroke-width="2"></circle>
  </g>
</svg>

上記は点の数が 4 つの三次ベジェ曲線です。

```typescript
function drawBezier(a: Point, b: Point, c: Point): void {
  let px = a.x;
  let py = a.y;

  const max = 100;
  for (let i = 1; i <= max; i++) {
    const t = i / max;
    const ab = leap(a, b, t);
    const bc = leap(b, c, t);
    const d = leap(ab, bc, t);
    p.line(px, py, d.x, d.y);
    px = d.x;
    py = d.y;
  }
}
```

線形補間による二次ベジェ曲線を描くコード例です。

## ベジェ曲線の特徴

- 与えられた点のうち、最初の点を始点、最後の点を終点、間にある点を制御点と呼びます。
- 実際に描かれるベジェ曲線は制御点を通ることはありません。
- N 個の点からできる曲線は N-1 次曲線となります。

線形補間で一つの点が求まるまで計算するのではなく、一つの式で計算する方法があります。

点 ABC、補間係数 t が与えられている状態で二次ベジェ曲線を描くとします。

点 AB 間の補間係数 t による線形補間の式は $a \times (1 - t) + b \times t$  
点 BC 間の補間係数 t による線形補間の式は $b \times (1 - t) + c \times t$

この 2 つの式から求まる点から更に線形補間をするので、

$(a \times (1 - t) + b \times t)(1 - t) + (b \times (1 - t) + c \times t) \times t$

が、求めたい点の位置になります。

```typescript
function calcBezier(a: number, b: number, c: number, t: number): number {
  return (a * (1 - t) + b * t) * (1 - t) + (b * (1 - t) + c * t) * t;
}

function drawBezier(a: Point, b: Point, c: Point): void {
  let px = a.x;
  let py = a.y;

  const max = 100;
  for (let i = 1; i <= max; i++) {
    const t = i / max;
    const x = calcBezier(a.x, b.x, c.x, t);
    const y = calcBezier(a.y, b.y, c.y, t);
    p.line(px, py, x, y);
    px = x;
    py = y;
  }
}
```

上記で求めた式を利用した二次ベジェ曲線を描くコード例です。

三次以上も同じように計算すればいいのですが、かなりややこしい計算になるので、もう少し楽な計算方法を試してみます。

| $(x+y)^n$ | 展開した式                    |
| :-------- | :---------------------------- |
| $(x+y)^1$ | $x+y$                         |
| $(x+y)^2$ | $x^2+2xy+y^2$                 |
| $(x+y)^3$ | $x^3+3x^2y+3xy^2+y^3$         |
| $(x+y)^4$ | $x^4+4x^3y+6x^2y^2+4xy^3+y^4$ |

$(x+y)^n$を[二項定理](/59bd1ded/)などを利用して展開すると上記のような式になりますが、ここで x を$(1-t)$、y を$t$に置き換えます。

| 次数 | x を$(1-t)$、y を$t$に置き換えた場合                                                    |
| :--- | :-------------------------------------------------------------------------------------- |
| 一次 | $(1-t)+t$                                                                               |
| 二次 | $(1-t)^2+2 \cdot (1-t) \cdot t+t^2$                                                     |
| 三次 | $(1-t)^3+3 \cdot (1-t)^2 \cdot t +3 \cdot (1-t) \cdot t^2 + t^3$                        |
| 四次 | $(1-t)^4+4 \cdot (1-t)^3 \cdot t+6 \cdot (1-t)^2 \cdot t^2+4 \cdot (1-t) \cdot t^3+t^4$ |

この置き換えた式が実際にベジェ曲線で使用される式で、初項 _ 点 A, 第 2 項 _ 点 B, 第 3 項 \* 点 C...と項ごとに位置を掛ければ、補間係数 t における位置が算出できます。

例えば点 ABCD を渡して三次ベジェ曲線の位置を求める場合は、下記の式になります。

$A \cdot (1-t)^3 + B \cdot 3 \cdot (1-t)^2 \cdot t + C \cdot 3 \cdot (1-t) \cdot t^2 + D \cdot t^3$

```typescript
function calcBezier3(a: Point, b: Point, c: Point, d: Point, t: number): Point {
  const x =
    a.x * (1 - t) ** 3 +
    b.x * 3 * (1 - t) ** 2 * t +
    c.x * 3 * (1 - t) * t ** 2 +
    d.x * t ** 3;
  const y =
    a.y * (1 - t) ** 3 +
    b.y * 3 * (1 - t) ** 2 * t +
    c.y * 3 * (1 - t) * t ** 2 +
    d.y * t ** 3;
  return { x, y };
}

function drawBezier3(a: Point, b: Point, c: Point, d: Point): void {
  let px = a.x;
  let py = a.y;
  const max = 100;

  for (let i = 1; i <= max; i++) {
    const t = i / max;
    const point = calcBezier3(a, b, c, d, t);
    p.line(px, py, point.x, point.y);
    px = point.x;
    py = point.y;
  }
}
```

## ソースコード

[point.ts](./static/code/946c9cf0/point.ts) / [app.ts](./static/code/946c9cf0/app.ts)

<script>
"use strict";

{
  function lerp(a, b, t) {
    return a + (b - a) * t;
  }

  function lerpPoint(a, b, t) {
    return { x: lerp(a.x, b.x, t), y: lerp(a.y, b.y, t) };
  }

  function updateTransform(p, o) {
    p.setAttribute("transform",  "translate(" + o.x + "," + o.y + ")");
  }

  function updateLine(p, a, b) {
    p.setAttribute("d", "M" + a.x + " " + a.y + " L" + b.x + " " + b.y);
  }

  function updateBezier2(p, a, b, c) {
    p.setAttribute("d", "M" + a.x + " " + a.y + " Q" + b.x + " " + b.y + " " + c.x + " "  + c.y);
  }

  function updateBezier3(p, a, b, c, d) {
    p.setAttribute("d", "M" + a.x + " " + a.y + " C" + b.x + " " + b.y + " " + c.x + " "  + c.y + " " + d.x + " "  + d.y);
  }

  document.addEventListener("DOMContentLoaded", function(){
    {
      const svg = document.getElementsByClassName("svg0")[0];
      const a = { x: 10, y: 150 };
      const b = { x: 250, y: 30 };
      const c = { x: 580, y: 180 };
      const p0 = svg.getElementsByClassName("p0")[0];
      const g0 = svg.getElementsByClassName("g0")[0];
      const g1 = svg.getElementsByClassName("g1")[0];
      const g2 = svg.getElementsByClassName("g2")[0];
      const bezier = svg.getElementsByClassName("bezier")[0];
      let dt = 0.004;
      let t = 0;
    
      function update() {
        t += dt;
        if (t < 0 || t > 1) {
          dt *= -1;
          t = Math.min(1, Math.max(0, t));
        }
        const d = lerpPoint(a, b, t);
        const e = lerpPoint(b, c, t);
        const f = lerpPoint(d, e, t);
  
        updateTransform(g0, d);
        updateTransform(g1, e);
        updateTransform(g2, f);
  
        updateLine(p0, d, e);

        updateBezier2(bezier, a, d, f);
  
        requestAnimationFrame(update);
      }
      update();
    }

    {
      const svg = document.getElementsByClassName("svg1")[0];
      const a = { x: 10, y: 150 };
      const b = { x: 150, y: 30 };
      const c = { x: 350, y: 180 };
      const d = { x: 580, y: 80 };
      const p0 = svg.getElementsByClassName("p0")[0];
      const p1 = svg.getElementsByClassName("p1")[0];
      const p2 = svg.getElementsByClassName("p2")[0];
      const g0 = svg.getElementsByClassName("g0")[0];
      const g1 = svg.getElementsByClassName("g1")[0];
      const g2 = svg.getElementsByClassName("g2")[0];
      const g3 = svg.getElementsByClassName("g3")[0];
      const g4 = svg.getElementsByClassName("g4")[0];
      const g5 = svg.getElementsByClassName("g5")[0];
      const bezier = svg.getElementsByClassName("bezier")[0];
      let dt = 0.004;
      let t = 0;
    
      function update() {
        t += dt;
        if (t < 0 || t > 1) {
          dt *= -1;
          t = Math.min(1, Math.max(0, t));
        }

        const e = lerpPoint(a, b, t);
        const f = lerpPoint(b, c, t);
        const g = lerpPoint(c, d, t);
        const h = lerpPoint(e, f, t);
        const i = lerpPoint(f, g, t);
        const j = lerpPoint(h, i, t);
  
        updateTransform(g0, e);
        updateTransform(g1, f);
        updateTransform(g2, g);
        updateTransform(g3, h);
        updateTransform(g4, i);
        updateTransform(g5, j);

        updateLine(p0, e, f);
        updateLine(p1, f, g);
        updateLine(p2, h, i);

        updateBezier3(bezier, a, e, h, j);
  
        requestAnimationFrame(update);
      }
      update();
    }
  });
}
</script>
