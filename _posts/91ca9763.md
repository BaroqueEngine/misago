---
title: "累積和"
weight: 70
num: 511
hash: "91ca9763"
tags: ["array"]
---

## コード例

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
  vector<int> v = {3, 1, 5, 8, 2};
  vector<int> t = {0};
  for (int i = 0; i < v.size(); i++) {
    t.push_back(t.back() + v[i]);
  }
  cout << t[5] - t[0] << endl; // [0, 5) => 19
  cout << t[5] - t[2] << endl; // [2, 5) => 15
  cout << t[2] - t[2] << endl; // [2, 2) => 0
}
```

## 解説/アルゴリズム

累積和は、$ O(N) $ の前処理を行うことによって、配列上の区間の総和を $O(1)$ で求めることができるアルゴリズムです。

| 添字 | [0] | [1] | [2] | [3] | [4] |
| :--- | :-- | :-- | :-- | :-- | :-- |
| 要素 | 3   | 1   | 5   | 8   | 2   |

まず対象となる配列 v を用意します。

| 添字   | [0] | [1] | [2]     | [3]         | [4]             | [5]                 |
| :----- | :-- | :-- | :------ | :---------- | :-------------- | :------------------ |
| 計算式 | 0   | [0] | [0]+[1] | [0]+[1]+[2] | [0]+[1]+[2]+[3] | [0]+[1]+[2]+[3]+[4] |
| 要素   | 0   | 3   | 4       | 9           | 17              | 19                  |

新しい配列 t を用意して下記の計算式で値を代入していきます。

- t[0] には 0
- t[1] には v[0]
- t[2] には v[0] + v[1]
- t[3] には v[0] + v[1] + v[2]
- t[n] には v[0] + v[1] + v[2] + ... v[n - 1]

と配列に値を入れていきます。

```cpp
vector<int> v = {3, 1, 5, 8, 2};
vector<int> t = {0};
for (int i = 0; i < v.size(); i++) {
  t.push_back(t.back() + v[i]);
}
```

この代入処理はコード例のように $O(N)$ で記述できます。

```cpp
cout << t[5] - t[0] << endl; // [0, 5) => 19
cout << t[5] - t[2] << endl; // [2, 5) => 15
cout << t[2] - t[2] << endl; // [2, 2) => 0
```

求めた配列 t を `t[b] - t[a]` のように使用すると、v[a]～ v[b-1] の値の総和を求めることができます。

| 添字   | [0] | [1] | [2]     | [3]         | [4]             | [5]                 |
| :----- | :-- | :-- | :------ | :---------- | :-------------- | :------------------ |
| 計算式 | 0   | [0] | [0]+[1] | [0]+[1]+[2] | [0]+[1]+[2]+[3] | [0]+[1]+[2]+[3]+[4] |
| 要素   | 0   | 3   | 4       | 9           | 17              | 19                  |

たとえば `t[5] - t[2]` というのは、配列 v の `[0]+[1]+[2]+[3]+[4] - [0]+[1]` で、 `[0]+[1]` の部分が消えて `[2]+[3]+[4]` だけが残るのがわかります。
